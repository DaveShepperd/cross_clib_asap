reg = 0
.macro nr num
r'num = %num
.endm
.rept 32
nr \reg
reg = reg + 1
.endr

.SP = %29
.RP = %28
.FP = %27
.LP = %26

	.psect text
	.globl fputc

.ifeq 1
void i_fputn(
  void          **stream,
  const char    *src,
  int           *len,
  int           *total_count,
  int           repeat
  )
{
  int i = *len;

  *total_count += i;
  if (repeat)
    while (0 < i--)
      fputc(*src, *(FILE **)stream);	/* Replace this with actual code to do the I/O */
  else
    while (0 < i--)
      fputc(*src++, *(FILE **)stream);	/* Replace this with actual code to do the I/O */
  *len = 0;
}
.endc

;At entry:
stream = r1
src = r2
len = r3
total_count = r4
repeat = r5


i_fputn::
	ld.c r6,r3[0]	;get length from caller
	beq 40$
	sub .SP,.SP,4*4	;make room on the stack
	st .RP,.SP[4*0]
	st r11,.SP[4*1]
	st r12,.SP[4*2]
	st r13,.SP[4*3]
;Now our registers are:
stream = r11
src    = r12
len    = r13
	ld stream,r1[0]	;get stream
	add src,r2,0	;get src
	add len,r6,0	;keep a copy of length from caller
	ld r1,r4[0]	;compute *total_count += len
	add r1,len,0
	st r1,r4[0]
	or.c r0,repeat,0 ;.ne. if to repeat one char
	bne 20$
	st r0,r3[0]	;clear caller's length
	
	or.c r0,len,0	;check count.
10$:	ble 30$		;done
	sub len,len,1	;take one anyway
	ldb r1,src[0]	;get byte
	add src,src,1	;bump pointer
	bsr .RP,fputc
	or r2,stream,0	;get stream
	bra 10$
	or.c r0,len,0	;check count.
	
20$:	or.c r0,len,0	;check count.
	ld src,src[0]	;get char to repeat
25$:	ble 30$		;done
	sub len,len,1	;take one anyway
	add r1,src,0	;get byte
	bsr .RP,fputc
	or r2,stream,0	;get stream
	bra 25$
	or.c r0,len,0	;check count.
	
30$:	ld .RP,.SP[4*0]
	ld r11,.SP[4*1]
	ld r12,.SP[4*2]
	ld r13,.SP[4*3]
40$:	jsr r0,.RP[0]
	add .SP,.SP,4*4	;pop from stack

